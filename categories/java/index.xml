<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on </title>
    <link>https://blog.laelaps.us/categories/java/</link>
    <description>Recent content in Java on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 06 Jul 2023 19:38:17 +0800</lastBuildDate><atom:link href="https://blog.laelaps.us/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java集合Iterator</title>
      <link>https://blog.laelaps.us/posts/java/iterator/</link>
      <pubDate>Thu, 06 Jul 2023 19:38:17 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/iterator/</guid>
      <description>为什么会有集合 在Java中一切皆对象，但是我们在编写程序的时候，我们根本不知道会有多少个对象，对象的周期，如何保存对象，尽管我们可以使用变量去保存对象，但是每一个对象都不可能使用一个变量，我们可以使用数组去保存变量，但是新的问题是我们怎么分配数组的大小，太小了我们不够去存储变量，而太大了者浪费资；但是我们似乎可以使用一个对象去代替我们去保存，我们只要去问他索取或者是将对象交给他来保存，我们就可以不用花很多的精力去管理我们的对象啊，而这个对象就是我们所说的集合，我们可以简单的使用集合给我提供的接口来管理变量，而不用我们自己去实现，集合还会自动的扩充自己的大小。
集合关系图 在这里可以看见，我们所有的集合都是实现了Collection和Map接口，而他们两个都同样继承了iterator接口（实际上继承的不是iterator接口，而是iterable接口）。
Iterator 这是Java集合必须实现的一个接口，他用来遍历集合，在传统的做法中，我们一般是使用for循环来遍历集合，但是Java为我们实现了Iterator，所以我们可以使用他来遍历集合。
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(List.of(&amp;#34;abc&amp;#34;, &amp;#34;xyz&amp;#34;, &amp;#34;12&amp;#34;, &amp;#34;pq&amp;#34;, &amp;#34;abcd&amp;#34;, &amp;#34;1234&amp;#34;)); // 传统方法遍历 for (int i = 0; i &amp;lt; list.size(); i++){ System.out.print(list.get(i)+ &amp;#34; &amp;#34;); } System.out.println(); // 使用Iterator来进行遍历 Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.print(iterator.next() + &amp;#34; &amp;#34;); } 我们可能会想使用forEach()来遍历集合，其实forEach内部也是使用的Iterator来遍历。
// Iterable 接口下对forEach的实现 default void forEach(Consumer&amp;lt;? super T&amp;gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } 但是值得注意的是，我们并不能在for循环中进行remove操作，这样会导致一些错误，应该避免这种情况，但是在迭代的时候可以进行相应的操作。
Java中的接口 public interface Iterator&amp;lt;E&amp;gt; { boolean hasNext(); E next(); default void remove() { throw new UnsupportedOperationException(&amp;#34;remove&amp;#34;); } default void forEachRemaining(Consumer&amp;lt;?</description>
    </item>
    
    <item>
      <title>Java 函数式接口</title>
      <link>https://blog.laelaps.us/posts/java/functionalinterface/</link>
      <pubDate>Mon, 03 Jul 2023 09:05:31 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/functionalinterface/</guid>
      <description>函数式接口 函数式接口（Functional interface）是有且只有一个抽象方法的接口。在java.util.function包中有许多非常通用的函数式接口。
自定义函数接口 自定义函数接口跟我们普通的定义函数接口没有任何的区别，但是我们有一个可选的@FunctionalInterface来注解这个接口，这个可以保证这个接口有只能有一个抽象方法；在javadoc中也会显示这个接口为一个函数式编接口。
@FunctionalInterface public interface Multiply { int multiplyAB(int A, int B); } public static void main(String[] args) { System.out.println(multiplyAB(1, 10, (a, b) -&amp;gt; a * b)); } public static int multiplyAB(int a, int b, Multiply multiply){ return multiply.multiplyAB(a,b); } 常用函数式接口 Supplier接口 对象实例的提供者，有一个名为get的抽象方法，没有任何参数，返回一个泛型对象；我们需要去实现get方法，让他生产一个泛型对象。
package java.util.function; @FunctionalInterface public interface Supplier&amp;lt;T&amp;gt; { T get(); } 除了Supplier 接口的使用，我们还可以指定类型，如BooleanJSupplier DoubleSupplier IntSupplier LongSupplier。 |接口名称|方法名称|方法签名|
Person person = (Person) Optional.empty().orElseGet(() -&amp;gt; new Person(&amp;#34;laelaps&amp;#34;)); System.</description>
    </item>
    
    <item>
      <title>Java Lambda表达式</title>
      <link>https://blog.laelaps.us/posts/java/lambda/</link>
      <pubDate>Sun, 02 Jul 2023 15:25:11 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/lambda/</guid>
      <description>是什么？ Java的lambda表达式是一个可传递的代码块，可以在之后执行一次或者多次。 我们都知道Java是一种面向对象的语言，所以我们如果想传递一个代码款，我们必须构造一个对象，然后在对象中实现一个方法包含所需要的代码块。
// 实现一个内部类来传递需要实现的代码 Thread thread1 = new Thread(new Runnable() { @Override public void run() { System.out.println(&amp;#34;abc&amp;#34;); } }); // 使用lambda表达式 new Thread(() -&amp;gt; System.out.println(&amp;#34;xyz&amp;#34;)).start(); 语法 Java中lambda表达式的形式：参数 -&amp;gt;（箭头）{代码块}/一个表达式。
如果需要实现的方法代码很多，可以将代码放入一个{}中 // 使用一个代码块实现，将代码放入一个{}中 Arrays.sort(arr, (String str1, String str2) -&amp;gt; { if(str1.length() &amp;lt; str2.length()) return -1; else if(str1.length() == str2.length()) return 0; else return 1; }); 如果lambda表达式可以推导出参数的字符串，我们可以参数的类型省去，但是值得注意的是Java是一种强类型的编程语言，他需要明确的知道参数的类型，这里可以省去的原因是Java编译器可以从上下文中推到出来。 Arrays.sort(arr, (str1, str2) -&amp;gt; { if(str1.length() &amp;lt; str2.length()) return -1; else if(str1.length() == str2.length()) return 0; else return 1; }); 如果lambada表达式只有一个参数，我们可以同时将参数类型以及()省去。 List&amp;lt;String&amp;gt; strings = List.</description>
    </item>
    
  </channel>
</rss>
