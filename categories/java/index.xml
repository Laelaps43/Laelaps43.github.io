<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on </title>
    <link>https://blog.laelaps.us/categories/java/</link>
    <description>Recent content in Java on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Jul 2023 09:05:31 +0800</lastBuildDate><atom:link href="https://blog.laelaps.us/categories/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java 函数式接口</title>
      <link>https://blog.laelaps.us/posts/java/functionalinterface/</link>
      <pubDate>Mon, 03 Jul 2023 09:05:31 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/functionalinterface/</guid>
      <description>函数式接口 函数式接口（Functional interface）是有且只有一个抽象方法的接口。在java.util.function包中有许多非常通用的函数式接口。
自定义函数接口 自定义函数接口跟我们普通的定义函数接口没有任何的区别，但是我们有一个可选的@FunctionalInterface来注解这个接口，这个可以保证这个接口有只能有一个抽象方法；在javadoc中也会显示这个接口为一个函数式编接口。
@FunctionalInterface public interface Multiply { int multiplyAB(int A, int B); } public static void main(String[] args) { System.out.println(multiplyAB(1, 10, (a, b) -&amp;gt; a * b)); } public static int multiplyAB(int a, int b, Multiply multiply){ return multiply.multiplyAB(a,b); } 常用函数式接口 Supplier接口 对象实例的提供者，有一个名为get的抽象方法，没有任何参数，返回一个泛型对象；我们需要去实现get方法，让他生产一个泛型对象。
package java.util.function; @FunctionalInterface public interface Supplier&amp;lt;T&amp;gt; { T get(); } 除了Supplier 接口的使用，我们还可以指定类型，如BooleanJSupplier DoubleSupplier IntSupplier LongSupplier。 |接口名称|方法名称|方法签名|
Person person = (Person) Optional.empty().orElseGet(() -&amp;gt; new Person(&amp;#34;laelaps&amp;#34;)); System.</description>
    </item>
    
    <item>
      <title>Java Lambda表达式</title>
      <link>https://blog.laelaps.us/posts/java/lambda/</link>
      <pubDate>Sun, 02 Jul 2023 15:25:11 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/lambda/</guid>
      <description>是什么？ Java的lambda表达式是一个可传递的代码块，可以在之后执行一次或者多次。 我们都知道Java是一种面向对象的语言，所以我们如果想传递一个代码款，我们必须构造一个对象，然后在对象中实现一个方法包含所需要的代码块。
// 实现一个内部类来传递需要实现的代码 Thread thread1 = new Thread(new Runnable() { @Override public void run() { System.out.println(&amp;#34;abc&amp;#34;); } }); // 使用lambda表达式 new Thread(() -&amp;gt; System.out.println(&amp;#34;xyz&amp;#34;)).start(); 语法 Java中lambda表达式的形式：参数 -&amp;gt;（箭头）{代码块}/一个表达式。
如果需要实现的方法代码很多，可以将代码放入一个{}中 // 使用一个代码块实现，将代码放入一个{}中 Arrays.sort(arr, (String str1, String str2) -&amp;gt; { if(str1.length() &amp;lt; str2.length()) return -1; else if(str1.length() == str2.length()) return 0; else return 1; }); 如果lambda表达式可以推导出参数的字符串，我们可以参数的类型省去，但是值得注意的是Java是一种强类型的编程语言，他需要明确的知道参数的类型，这里可以省去的原因是Java编译器可以从上下文中推到出来。 Arrays.sort(arr, (str1, str2) -&amp;gt; { if(str1.length() &amp;lt; str2.length()) return -1; else if(str1.length() == str2.length()) return 0; else return 1; }); 如果lambada表达式只有一个参数，我们可以同时将参数类型以及()省去。 List&amp;lt;String&amp;gt; strings = List.</description>
    </item>
    
  </channel>
</rss>
