<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>https://blog.laelaps.us/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 02 Jul 2023 15:25:11 +0800</lastBuildDate><atom:link href="https://blog.laelaps.us/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java Lambda表达式</title>
      <link>https://blog.laelaps.us/posts/java/lambda/</link>
      <pubDate>Sun, 02 Jul 2023 15:25:11 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/lambda/</guid>
      <description>是什么？ Java的lambda表达式是一个可传递的代码块，可以在之后执行一次或者多次。 我们都知道Java是一种面向对象的语言，所以我们如果想传递一个代码款，我们必须构造一个对象，然后在对象中实现一个方法包含所需要的代码块。
// 实现一个内部类来传递需要实现的代码 Thread thread1 = new Thread(new Runnable() { @Override public void run() { System.out.println(&amp;#34;abc&amp;#34;); } }); // 使用lambda表达式 new Thread(() -&amp;gt; System.out.println(&amp;#34;xyz&amp;#34;)).start(); 语法 Java中lambda表达式的形式：参数 -&amp;gt;（箭头）{代码块}/一个表达式。
如果需要实现的方法代码很多，可以将代码放入一个{}中 // 使用一个代码块实现，将代码放入一个{}中 Arrays.sort(arr, (String str1, String str2) -&amp;gt; { if(str1.length() &amp;lt; str2.length()) return -1; else if(str1.length() == str2.length()) return 0; else return 1; }); 如果lambda表达式可以推导出参数的字符串，我们可以参数的类型省去，但是值得注意的是Java是一种强类型的编程语言，他需要明确的知道参数的类型，这里可以省去的原因是Java编译器可以从上下文中推到出来。 Arrays.sort(arr, (str1, str2) -&amp;gt; { if(str1.length() &amp;lt; str2.length()) return -1; else if(str1.length() == str2.length()) return 0; else return 1; }); 如果lambada表达式只有一个参数，我们可以同时将参数类型以及()省去。 List&amp;lt;String&amp;gt; strings = List.</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://blog.laelaps.us/posts/algorithm/mergesort/</link>
      <pubDate>Sat, 01 Jul 2023 15:37:23 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/algorithm/mergesort/</guid>
      <description>归并排序是一次采用分而治之算法解决排序的问题，他是一种高效的，可以产生稳定的排序方法。
主要思想 归并排序是一中分而治之的算法，他将一个大问题不断分解成一序列小问题，在所有的小问题中寻求最优解。 在排序的过程中，我们将一个大的数组，分解成两个较小的子数组，而在将这两个子数组在次进行递归划分，知道子数组长度为1（此时我们认为在他以及是有序的），然后对子数组进行排序。 排序示意图： 性能分析 算法的时间复杂度在最坏，最好，平均复杂度都为O(nlogn)，而空间复杂度为O(n)（可以使用空间复杂度为O(1)）。
算法实现 归并 我们要将两个已排序的子数组进行归并，其实就是将两个子数组在次合并成一个大的已经排序好的数组。这里我们需要一个辅助数组来存储将要归并的数组，通常这个辅助数组的大小通常为要排序数组的大小。我们将要排序的子数组全部拷贝到辅助数组，然后再将排序好的数据复制到要排序的数组。
/** * 排序归并数组 * 归并 a[lo .. mid] 和 a[mid + 1 .. hi] */ private static void merge(Integer[] a, int lo, int mid, int hi){ int i = lo, j = mid + 1; // 复制数组到辅助数组，因为源数组会被排序结果覆盖 if (hi + 1 - lo &amp;gt;= 0) System.arraycopy(a, lo, aux, lo, hi + 1 - lo); for (int k = lo; k &amp;lt;= hi; k++){ // 需要比较k次 // 左半边用尽，将右半边剩余的数据依次放入 if ( i &amp;gt; mid) a[k] = aux[j++]; // 右半边用尽，将左半边剩余的数据依次放入 else if ( j &amp;gt; hi) a[k] = aux[i++]; // 左半边首字符小于右半边字符，将左半边字符放入 else if ( aux[i] &amp;lt; aux[j]) a[k] = aux[i++]; // 左半边首字符大于右半边字符，将右半边字符放入 else a[k] = aux[j++]; } } 自顶向下（递归） 他将数组不断的分解，直到分解到大小为1。然后对左半部分进行排序，然后在对右半部分进行排序，最后将左右两部分合并在一起，不断的递归后完成对数组的排序。 public static void sortByRec(Integer[] a){ aux = new Integer[a.</description>
    </item>
    
    <item>
      <title>2023年7月计划</title>
      <link>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47%E6%9C%88%E8%AE%A1%E5%88%92/</link>
      <pubDate>Fri, 23 Jun 2023 23:56:09 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47%E6%9C%88%E8%AE%A1%E5%88%92/</guid>
      <description>Content git docker JAVA基础需要过一遍（lambda、线程、集合、反射） 学习Go语言 力扣题目(50) 数据库 </description>
    </item>
    
    <item>
      <title>2023年7-10月计划</title>
      <link>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47-10%E6%9C%88%E8%AE%A1%E5%88%92/</link>
      <pubDate>Fri, 23 Jun 2023 23:17:37 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47-10%E6%9C%88%E8%AE%A1%E5%88%92/</guid>
      <description>煽情 这是我在即将要出去实习或者走向社会的最后四个月可以完完全全用来学习的机会，所以我需要一些计划用来完善自己，确保我能够在十一月的时候可以找到一个不错的实习；在这四个月里我知道会很痛苦，但是希望可以坚持和完成自己所列的一些计划吧？ PS: 这里只列举一些较大的计划，详细的将会列举到每月计划中。
Content 计划 论文的初稿 JAVA基础需要过一遍（lambda、线程、集合、反射） Spring家族需要重新过一遍 将那个网盘项目继续写下去 需要学习kafka JVM需要学习 数据库需要学习 Redis需要仔细看一遍 计算机网络需要在看一遍（计算机网络自顶向下方法 第2、3、4、5、6章） 需要刷一些力扣题目（200） 学习Go语言 一些工具（git、docker） 以上这些可能是就是按照我的简历所写来的计划的，看来我对我简历所写的好像并不算很满意，但是，这最后四个月不就是这样的吗？
补充 这里是一些不太重要的事情，如果可以完成的话，那就试试吧！
系统学习Js 再看一遍Vue的文档 系统的学习一下Linux（尽管会使用过但是还是不太熟悉） 学习Pytho的爬虫 以上可以说就是这四个月需要做的一些事，可能有一些不全面，那就等想到在补充吧！在我的影响里，在这种比较大的假期的时候，我都会有一些计划，但是从来没有一次会写下来，所有他也就永远留存在过去，就更别说完成了。总之自己可以完成以上一些计划吧！
2023.6.23 夜</description>
    </item>
    
  </channel>
</rss>
