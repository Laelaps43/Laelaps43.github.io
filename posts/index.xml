<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>https://blog.laelaps.us/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 11 Jul 2023 08:28:15 +0800</lastBuildDate><atom:link href="https://blog.laelaps.us/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>AbstractList</title>
      <link>https://blog.laelaps.us/posts/java/abstractlist/</link>
      <pubDate>Tue, 11 Jul 2023 08:28:15 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/abstractlist/</guid>
      <description>Content AbstractList扩展了AbstractCollection和实现了List；在这里有趣的是有5个内部类的实现。
removeRange protected void removeRange(int fromIndex, int toIndex) { ListIterator&amp;lt;E&amp;gt; it = listIterator(fromIndex); for (int i=0, n=toIndex-fromIndex; i&amp;lt;n; i++) { it.next(); it.remove(); } } 删除指定范围的元素，使用迭代器来实现，并且为一个protected方法。
subList public List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex) { subListRangeCheck(fromIndex, toIndex, size()); return (this instanceof RandomAccess ? new RandomAccessSubList&amp;lt;&amp;gt;(this, fromIndex, toIndex) : new SubList&amp;lt;&amp;gt;(this, fromIndex, toIndex)); } RandomAccess 是一个标记接口，他是一个空的接口，通常用来表示我们的集合是支持随机访问，所有他的功能就仅仅是一个标记的作用。 在这里如果我们的集合实现了RandomAccess这个空接口，那么他返回的就是RandomAccessSubList，否则返回的就是一个SubList的内部类。
Itr 他实现了Iterator接口，供AbstractList使用迭代器。
private class Itr implements Iterator&amp;lt;E&amp;gt; { int cursor = 0; int lastRet = -1; int expectedModCount = modCount; public boolean hasNext() { return cursor !</description>
    </item>
    
    <item>
      <title>Java集合ListIterator</title>
      <link>https://blog.laelaps.us/posts/java/listiterator/</link>
      <pubDate>Mon, 10 Jul 2023 15:58:37 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/listiterator/</guid>
      <description>ListIterator ListIterator是一只适用于List的双向迭代器；他扩展了默认的Iterator接口。
ListIterator 方法 方法 描述 boolean hasNext() 判断迭起器向前迭代时是否具有元素 boolean hasPrevious() 判断迭起器向后迭代时是否具有元素 E next(); 返回下一个元素 E previous(); 返回上一个元素 int nextIndex(); 返回下一个元素的索引，如果在末尾则返回list的大小 int previousIndex(); 返回上一个元素的索引，如果在list的开头返回 -1 void add(E e) 将指定的元素插入列表中，位于next 之前 void remove(); 删除由next 或者 previous 返回的最后一个元素 void set(E e); 替换由next 或者 previous 返回的最后一个元素 @Test public void testList(){ List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;(); strings.add(&amp;#34;a&amp;#34;); strings.add(&amp;#34;b&amp;#34;); strings.add(&amp;#34;c&amp;#34;); ListIterator&amp;lt;String&amp;gt; stringListIterator = strings.listIterator(); stringListIterator.add(&amp;#34;1&amp;#34;); System.out.println(stringListIterator.hasNext()); System.out.println(stringListIterator.hasPrevious()); System.out.println(stringListIterator.next()); System.out.println(stringListIterator.previous()); System.out.println(stringListIterator.nextIndex()); System.out.println(stringListIterator.previousIndex()); stringListIterator.next(); stringListIterator.next(); stringListIterator.remove(); System.out.println(strings); } // 使用ListIterator倒序遍历 @Test public void testList5(){ List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;(); strings.</description>
    </item>
    
    <item>
      <title>Java集合List</title>
      <link>https://blog.laelaps.us/posts/java/list/</link>
      <pubDate>Mon, 10 Jul 2023 15:25:27 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/list/</guid>
      <description>Content List 是一个接口，是对应的是一组元素为有序的，可重复的集合；他基础于Collection，但List又有一些独特的方法。
位置相关 E get(int index); 接受一个int类型的参数index，index &amp;lt; 0 || index &amp;gt;= size() 触发越界异常。
E set(int index, E element); 在指定位置添加元素，添加成功后返回原来这个位置的元素。
void add(int index, E element); 在指定的位置上添加元素，在这个位置之后的元素（包括这个元素）向右移动。
E remove(int index); 删除指定位置上的元素
搜索 int indexOf(Object o); 在给定的List中查找o第一次出现位置，查找到返回所在位置，没有则返回-1。
int lastIndexOf(Object o); 与上面那个相反，这个是从后往前找。
迭代 ListIterator&amp;lt;E&amp;gt; listIterator() 返回一个ListIterator迭代器
ListIterator&amp;lt;E&amp;gt; listIterator(int index) 返回一ListIterator迭代器，但是他将这个”指针“放到指定的位置，所以next是指定的位置，而previous则是index - 1的位置。
@Test public void testList3(){ List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;(); strings.add(&amp;#34;a&amp;#34;); strings.add(&amp;#34;b&amp;#34;); strings.add(&amp;#34;c&amp;#34;); ListIterator&amp;lt;String&amp;gt; stringListIterator = strings.listIterator(1); System.out.println(stringListIterator.previousIndex()); System.out.println(stringListIterator.nextIndex()); } 范围操作 List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex) 返回的是一个List的一个视图，所有所有的操作都会返回在原来的数组之上。</description>
    </item>
    
    <item>
      <title>Java判断基本数据类型</title>
      <link>https://blog.laelaps.us/posts/java/judgeprimitivetype/</link>
      <pubDate>Sat, 08 Jul 2023 16:31:01 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/judgeprimitivetype/</guid>
      <description>Content 我们需要判断当前数据类型是不是基本数据类型，我们有以下一些方法：
1. class类提供的 isPrimitive方法 public void testIsPrimitiveType(){ System.out.println(int.class.isPrimitive()); System.out.println(String.class.isPrimitive()); System.out.println(boolean.class.isPrimitive()); System.out.println(void.class.isPrimitive()); System.out.println(Double.class.isPrimitive()); // false } 这个方法用于判断Class对象是否为一个基本数据类型和Void，如果是八大基本类型加void，则返回true，否则返回false。
2. class也可以使用isArray()判断是否为数组类型 public void testIsArray(){ int[] ints = new int[0]; System.out.println(ints.getClass().isArray()); System.out.println(&amp;#34;1&amp;#34;.getClass().isArray()); } 3. getName 引用类型不是数组类型 返回二进制名称 基本类型或者void，返回的是一个String字符串 数组类型，由多个或一个[后接内部形式的元素类型的名称组成。 @Test public void testGetName(){ MergeSort mergeSort = new MergeSort(); System.out.println(mergeSort.getClass().getName()); // us.laelaps.sort.MergeSort System.out.println(int.class.getName()); // int System.out.println(String.class.getName()); // java.lang.String System.out.println(void.class.getName()); // void int[] ints = new int[1]; System.out.println(ints.getClass().getName()); // [I String[][] strings = new String[2][3]; System.</description>
    </item>
    
    <item>
      <title>Java集合Collecton</title>
      <link>https://blog.laelaps.us/posts/java/collecton/</link>
      <pubDate>Sat, 08 Jul 2023 12:21:57 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/collecton/</guid>
      <description>Collection Collection是一个接口，他定义了一些对集合的通用方法。
removeIf default boolean removeIf(Predicate&amp;lt;? super E&amp;gt; filter) Collection 中的默认实现，接受一个Predicate函数，他在删除的时候也是采用的Iterator来迭代找到最佳的匹配数据，然后使用迭代器的remove()。
toArray 在Collection有以下三个方法：
Object[] toArray(); // 直接返回的就是一个Object类型的数组 &amp;lt;T&amp;gt; T[] toArray(T[] a); // 接受一个T[]的数组 // 接受一个lambda 函数，但是这个lambda函数返回的类型应该也是返回一个数组，因为他调用的是上一个函数 default &amp;lt;T&amp;gt; T[] toArray(IntFunction&amp;lt;T[]&amp;gt; generator){ return toArray(generator.apply(0)); } spliterator spliterator是Java 8加入的一个新接口，他和Iterator一样，用于遍历数据源的元素，与之不同的是他是为了并行执行而设计的。
stream 返回一个Stream流
parallelStream 返回一个可以并发的Stream流
AbstractCollection AbstractCollection实现了Collection接口的所有方法。
retainAll public boolean retainAll(Collection&amp;lt;?&amp;gt; c) 只保留交集的那一部分，也是使用迭代器的方式判断来判断c中是否含有相关的元素，没有执行使用迭代器的remove()。
finishToArray 迭代器中还有数据，我们将全部的数据拷贝到数组中。
// 源代码 private static &amp;lt;T&amp;gt; T[] finishToArray(T[] r, Iterator&amp;lt;?&amp;gt; it) { int len = r.length; int i = len; while (it.</description>
    </item>
    
    <item>
      <title>Java集合Iterator</title>
      <link>https://blog.laelaps.us/posts/java/iterator/</link>
      <pubDate>Thu, 06 Jul 2023 19:38:17 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/iterator/</guid>
      <description>为什么会有集合 在Java中一切皆对象，但是我们在编写程序的时候，我们根本不知道会有多少个对象，对象的周期，如何保存对象，尽管我们可以使用变量去保存对象，但是每一个对象都不可能使用一个变量，我们可以使用数组去保存变量，但是新的问题是我们怎么分配数组的大小，太小了我们不够去存储变量，而太大了者浪费资；但是我们似乎可以使用一个对象去代替我们去保存，我们只要去问他索取或者是将对象交给他来保存，我们就可以不用花很多的精力去管理我们的对象啊，而这个对象就是我们所说的集合，我们可以简单的使用集合给我提供的接口来管理变量，而不用我们自己去实现，集合还会自动的扩充自己的大小。
集合关系图 在这里可以看见，我们所有的集合都是实现了Collection和Map接口，而他们两个都同样继承了iterator接口（实际上继承的不是iterator接口，而是iterable接口）。
Iterator 这是Java集合必须实现的一个接口，他用来遍历集合，在传统的做法中，我们一般是使用for循环来遍历集合，但是Java为我们实现了Iterator，所以我们可以使用他来遍历集合。
List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(List.of(&amp;#34;abc&amp;#34;, &amp;#34;xyz&amp;#34;, &amp;#34;12&amp;#34;, &amp;#34;pq&amp;#34;, &amp;#34;abcd&amp;#34;, &amp;#34;1234&amp;#34;)); // 传统方法遍历 for (int i = 0; i &amp;lt; list.size(); i++){ System.out.print(list.get(i)+ &amp;#34; &amp;#34;); } System.out.println(); // 使用Iterator来进行遍历 Iterator&amp;lt;String&amp;gt; iterator = list.iterator(); while (iterator.hasNext()){ System.out.print(iterator.next() + &amp;#34; &amp;#34;); } 我们可能会想使用forEach()来遍历集合，其实forEach内部也是使用的Iterator来遍历。
// Iterable 接口下对forEach的实现 default void forEach(Consumer&amp;lt;? super T&amp;gt; action) { Objects.requireNonNull(action); for (T t : this) { action.accept(t); } } 但是值得注意的是，我们并不能在for循环中进行remove操作，这样会导致一些错误，应该避免这种情况，但是在迭代的时候可以进行相应的操作。
Java中的接口 public interface Iterator&amp;lt;E&amp;gt; { boolean hasNext(); E next(); default void remove() { throw new UnsupportedOperationException(&amp;#34;remove&amp;#34;); } default void forEachRemaining(Consumer&amp;lt;?</description>
    </item>
    
    <item>
      <title>Java 函数式接口</title>
      <link>https://blog.laelaps.us/posts/java/functionalinterface/</link>
      <pubDate>Mon, 03 Jul 2023 09:05:31 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/functionalinterface/</guid>
      <description>函数式接口 函数式接口（Functional interface）是有且只有一个抽象方法的接口。在java.util.function包中有许多非常通用的函数式接口。
自定义函数接口 自定义函数接口跟我们普通的定义函数接口没有任何的区别，但是我们有一个可选的@FunctionalInterface来注解这个接口，这个可以保证这个接口有只能有一个抽象方法；在javadoc中也会显示这个接口为一个函数式编接口。
@FunctionalInterface public interface Multiply { int multiplyAB(int A, int B); } public static void main(String[] args) { System.out.println(multiplyAB(1, 10, (a, b) -&amp;gt; a * b)); } public static int multiplyAB(int a, int b, Multiply multiply){ return multiply.multiplyAB(a,b); } 常用函数式接口 Supplier接口 对象实例的提供者，有一个名为get的抽象方法，没有任何参数，返回一个泛型对象；我们需要去实现get方法，让他生产一个泛型对象。
package java.util.function; @FunctionalInterface public interface Supplier&amp;lt;T&amp;gt; { T get(); } 除了Supplier 接口的使用，我们还可以指定类型，如BooleanJSupplier DoubleSupplier IntSupplier LongSupplier。 |接口名称|方法名称|方法签名|
Person person = (Person) Optional.empty().orElseGet(() -&amp;gt; new Person(&amp;#34;laelaps&amp;#34;)); System.</description>
    </item>
    
    <item>
      <title>Java Lambda表达式</title>
      <link>https://blog.laelaps.us/posts/java/lambda/</link>
      <pubDate>Sun, 02 Jul 2023 15:25:11 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/java/lambda/</guid>
      <description>是什么？ Java的lambda表达式是一个可传递的代码块，可以在之后执行一次或者多次。 我们都知道Java是一种面向对象的语言，所以我们如果想传递一个代码款，我们必须构造一个对象，然后在对象中实现一个方法包含所需要的代码块。
// 实现一个内部类来传递需要实现的代码 Thread thread1 = new Thread(new Runnable() { @Override public void run() { System.out.println(&amp;#34;abc&amp;#34;); } }); // 使用lambda表达式 new Thread(() -&amp;gt; System.out.println(&amp;#34;xyz&amp;#34;)).start(); 语法 Java中lambda表达式的形式：参数 -&amp;gt;（箭头）{代码块}/一个表达式。
如果需要实现的方法代码很多，可以将代码放入一个{}中 // 使用一个代码块实现，将代码放入一个{}中 Arrays.sort(arr, (String str1, String str2) -&amp;gt; { if(str1.length() &amp;lt; str2.length()) return -1; else if(str1.length() == str2.length()) return 0; else return 1; }); 如果lambda表达式可以推导出参数的字符串，我们可以参数的类型省去，但是值得注意的是Java是一种强类型的编程语言，他需要明确的知道参数的类型，这里可以省去的原因是Java编译器可以从上下文中推到出来。 Arrays.sort(arr, (str1, str2) -&amp;gt; { if(str1.length() &amp;lt; str2.length()) return -1; else if(str1.length() == str2.length()) return 0; else return 1; }); 如果lambada表达式只有一个参数，我们可以同时将参数类型以及()省去。 List&amp;lt;String&amp;gt; strings = List.</description>
    </item>
    
    <item>
      <title>归并排序</title>
      <link>https://blog.laelaps.us/posts/algorithm/mergesort/</link>
      <pubDate>Sat, 01 Jul 2023 15:37:23 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/algorithm/mergesort/</guid>
      <description>归并排序是一次采用分而治之算法解决排序的问题，他是一种高效的，可以产生稳定的排序方法。
主要思想 归并排序是一中分而治之的算法，他将一个大问题不断分解成一序列小问题，在所有的小问题中寻求最优解。 在排序的过程中，我们将一个大的数组，分解成两个较小的子数组，而在将这两个子数组在次进行递归划分，知道子数组长度为1（此时我们认为在他以及是有序的），然后对子数组进行排序。 排序示意图： 性能分析 算法的时间复杂度在最坏，最好，平均复杂度都为O(nlogn)，而空间复杂度为O(n)（可以使用空间复杂度为O(1)）。
算法实现 归并 我们要将两个已排序的子数组进行归并，其实就是将两个子数组在次合并成一个大的已经排序好的数组。这里我们需要一个辅助数组来存储将要归并的数组，通常这个辅助数组的大小通常为要排序数组的大小。我们将要排序的子数组全部拷贝到辅助数组，然后再将排序好的数据复制到要排序的数组。
/** * 排序归并数组 * 归并 a[lo .. mid] 和 a[mid + 1 .. hi] */ private static void merge(Integer[] a, int lo, int mid, int hi){ int i = lo, j = mid + 1; // 复制数组到辅助数组，因为源数组会被排序结果覆盖 if (hi + 1 - lo &amp;gt;= 0) System.arraycopy(a, lo, aux, lo, hi + 1 - lo); for (int k = lo; k &amp;lt;= hi; k++){ // 需要比较k次 // 左半边用尽，将右半边剩余的数据依次放入 if ( i &amp;gt; mid) a[k] = aux[j++]; // 右半边用尽，将左半边剩余的数据依次放入 else if ( j &amp;gt; hi) a[k] = aux[i++]; // 左半边首字符小于右半边字符，将左半边字符放入 else if ( aux[i] &amp;lt; aux[j]) a[k] = aux[i++]; // 左半边首字符大于右半边字符，将右半边字符放入 else a[k] = aux[j++]; } } 自顶向下（递归） 他将数组不断的分解，直到分解到大小为1。然后对左半部分进行排序，然后在对右半部分进行排序，最后将左右两部分合并在一起，不断的递归后完成对数组的排序。 public static void sortByRec(Integer[] a){ aux = new Integer[a.</description>
    </item>
    
    <item>
      <title>2023年7月计划</title>
      <link>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47%E6%9C%88%E8%AE%A1%E5%88%92/</link>
      <pubDate>Fri, 23 Jun 2023 23:56:09 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47%E6%9C%88%E8%AE%A1%E5%88%92/</guid>
      <description>Content git docker JAVA基础需要过一遍（~~lambda ~~、线程、集合、反射） 学习Go语言 力扣题目(50) 数据库 </description>
    </item>
    
    <item>
      <title>2023年7-10月计划</title>
      <link>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47-10%E6%9C%88%E8%AE%A1%E5%88%92/</link>
      <pubDate>Fri, 23 Jun 2023 23:17:37 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47-10%E6%9C%88%E8%AE%A1%E5%88%92/</guid>
      <description>煽情 这是我在即将要出去实习或者走向社会的最后四个月可以完完全全用来学习的机会，所以我需要一些计划用来完善自己，确保我能够在十一月的时候可以找到一个不错的实习；在这四个月里我知道会很痛苦，但是希望可以坚持和完成自己所列的一些计划吧？ PS: 这里只列举一些较大的计划，详细的将会列举到每月计划中。
Content 计划 论文的初稿 JAVA基础需要过一遍（lambda、线程、集合、反射） Spring家族需要重新过一遍 将那个网盘项目继续写下去 需要学习kafka JVM需要学习 数据库需要学习 Redis需要仔细看一遍 计算机网络需要在看一遍（计算机网络自顶向下方法 第2、3、4、5、6章） 需要刷一些力扣题目（200） 学习Go语言 一些工具（git、docker） 以上这些可能是就是按照我的简历所写来的计划的，看来我对我简历所写的好像并不算很满意，但是，这最后四个月不就是这样的吗？
补充 这里是一些不太重要的事情，如果可以完成的话，那就试试吧！
系统学习Js 再看一遍Vue的文档 系统的学习一下Linux（尽管会使用过但是还是不太熟悉） 学习Pytho的爬虫 以上可以说就是这四个月需要做的一些事，可能有一些不全面，那就等想到在补充吧！在我的影响里，在这种比较大的假期的时候，我都会有一些计划，但是从来没有一次会写下来，所有他也就永远留存在过去，就更别说完成了。总之自己可以完成以上一些计划吧！
2023.6.23 夜</description>
    </item>
    
  </channel>
</rss>
