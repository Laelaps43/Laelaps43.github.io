<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://blog.laelaps.us/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Jul 2023 15:37:23 +0800</lastBuildDate><atom:link href="https://blog.laelaps.us/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>归并排序</title>
      <link>https://blog.laelaps.us/posts/algorithm/mergesort/</link>
      <pubDate>Sat, 01 Jul 2023 15:37:23 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/algorithm/mergesort/</guid>
      <description>归并排序是一次采用分而治之算法解决排序的问题，他是一种高效的，可以产生稳定的排序方法。
主要思想 归并排序是一中分而治之的算法，他将一个大问题不断分解成一序列小问题，在所有的小问题中寻求最优解。 在排序的过程中，我们将一个大的数组，分解成两个较小的子数组，而在将这两个子数组在次进行递归划分，知道子数组长度为1（此时我们认为在他以及是有序的），然后对子数组进行排序。 排序示意图： 性能分析 算法的时间复杂度在最坏，最好，平均复杂度都为O(nlogn)，而空间复杂度为O(n)（可以使用空间复杂度为O(1)）。
算法实现 归并 我们要将两个已排序的子数组进行归并，其实就是将两个子数组在次合并成一个大的已经排序好的数组。这里我们需要一个辅助数组来存储将要归并的数组，通常这个辅助数组的大小通常为要排序数组的大小。我们将要排序的子数组全部拷贝到辅助数组，然后再将排序好的数据复制到要排序的数组。
/** * 排序归并数组 * 归并 a[lo .. mid] 和 a[mid + 1 .. hi] */ private static void merge(Integer[] a, int lo, int mid, int hi){ int i = lo, j = mid + 1; // 复制数组到辅助数组，因为源数组会被排序结果覆盖 if (hi + 1 - lo &amp;gt;= 0) System.arraycopy(a, lo, aux, lo, hi + 1 - lo); for (int k = lo; k &amp;lt;= hi; k++){ // 需要比较k次 // 左半边用尽，将右半边剩余的数据依次放入 if ( i &amp;gt; mid) a[k] = aux[j++]; // 右半边用尽，将左半边剩余的数据依次放入 else if ( j &amp;gt; hi) a[k] = aux[i++]; // 左半边首字符小于右半边字符，将左半边字符放入 else if ( aux[i] &amp;lt; aux[j]) a[k] = aux[i++]; // 左半边首字符大于右半边字符，将右半边字符放入 else a[k] = aux[j++]; } } 自顶向下（递归） 他将数组不断的分解，直到分解到大小为1。然后对左半部分进行排序，然后在对右半部分进行排序，最后将左右两部分合并在一起，不断的递归后完成对数组的排序。 public static void sortByRec(Integer[] a){ aux = new Integer[a.</description>
    </item>
    
    <item>
      <title>2023年7月计划</title>
      <link>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47%E6%9C%88%E8%AE%A1%E5%88%92/</link>
      <pubDate>Fri, 23 Jun 2023 23:56:09 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47%E6%9C%88%E8%AE%A1%E5%88%92/</guid>
      <description>Content git docker JAVA基础需要过一遍（lambda、线程、集合、反射） 学习Go语言 力扣题目(50) 数据库 </description>
    </item>
    
    <item>
      <title>2023年7-10月计划</title>
      <link>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47-10%E6%9C%88%E8%AE%A1%E5%88%92/</link>
      <pubDate>Fri, 23 Jun 2023 23:17:37 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/posts/plan/2023%E5%B9%B47-10%E6%9C%88%E8%AE%A1%E5%88%92/</guid>
      <description>煽情 这是我在即将要出去实习或者走向社会的最后四个月可以完完全全用来学习的机会，所以我需要一些计划用来完善自己，确保我能够在十一月的时候可以找到一个不错的实习；在这四个月里我知道会很痛苦，但是希望可以坚持和完成自己所列的一些计划吧？ PS: 这里只列举一些较大的计划，详细的将会列举到每月计划中。
Content 计划 论文的初稿 JAVA基础需要过一遍（lambda、线程、集合、反射） Spring家族需要重新过一遍 将那个网盘项目继续写下去 需要学习kafka JVM需要学习 数据库需要学习 Redis需要仔细看一遍 计算机网络需要在看一遍（计算机网络自顶向下方法 第2、3、4、5、6章） 需要刷一些力扣题目（200） 学习Go语言 一些工具（git、docker） 以上这些可能是就是按照我的简历所写来的计划的，看来我对我简历所写的好像并不算很满意，但是，这最后四个月不就是这样的吗？
补充 这里是一些不太重要的事情，如果可以完成的话，那就试试吧！
系统学习Js 再看一遍Vue的文档 系统的学习一下Linux（尽管会使用过但是还是不太熟悉） 学习Pytho的爬虫 以上可以说就是这四个月需要做的一些事，可能有一些不全面，那就等想到在补充吧！在我的影响里，在这种比较大的假期的时候，我都会有一些计划，但是从来没有一次会写下来，所有他也就永远留存在过去，就更别说完成了。总之自己可以完成以上一些计划吧！
2023.6.23 夜</description>
    </item>
    
    <item>
      <title>About Me</title>
      <link>https://blog.laelaps.us/about/</link>
      <pubDate>Thu, 22 Jun 2023 22:50:28 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/about/</guid>
      <description>你好，我是laelaps，一名即将步入社会的计算机爱好者。
在希腊神话中，laelaps是一只总能抓住任何猎物的狗，但他被利用来抓一只永远不能被抓到的狐狸。一只可以抓到任何猎物的狗，一只永远不能被抓到的狐狸，这形成了一个悖论，在最后宙斯将他们两个变成了两颗石头，并扔进了星空中，形成了Canis Major(Laelaps)和Canis Minor两个星座，而现在的他们仍然在星空中相互追逐。
建立这个博客的目的主要是因为自己看过的内容很容易忘记，虽然有在记笔记，但是总是不那么的完善，我希望可以用这个博客来记录我自己的学习路径，强化我的记忆，所以整个博客就是为了我自己而创建。博客使用hugo + hugo-theme-yinyang + Github Page搭建而成。</description>
    </item>
    
  </channel>
</rss>
