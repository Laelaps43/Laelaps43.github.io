<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Laelaps</title>
    <link>https://blog.laelaps.us/leetcodes/</link>
    <description>Recent content in Leetcode on Laelaps</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Jul 2023 18:31:55 +0800</lastBuildDate><atom:link href="https://blog.laelaps.us/leetcodes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>力扣24题解</title>
      <link>https://blog.laelaps.us/leetcodes/24/</link>
      <pubDate>Wed, 02 Aug 2023 06:37:05 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/leetcodes/24/</guid>
      <description>前言 这题是关于链表，那么我首先想到的就是使用递归去解决，但是我在这个过程中，发现空间复杂度有点大，所有第二次那么就直接使用迭代了。
递归 func swapPairs(head *ListNode) *ListNode { if head == nil || head.Next == nil{ return head } nextNode := head.Next head.Next, nextNode.Next = swapPairs(nextNode.Next), head return nextNode } 迭代 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func swapPairs(head *ListNode) *ListNode { var tailPre,nextNode,nodeTmp *ListNode = nil, nil, nil node := head for node != nil &amp;amp;&amp;amp; node.</description>
    </item>
    
    <item>
      <title>力扣53题解</title>
      <link>https://blog.laelaps.us/leetcodes/53/</link>
      <pubDate>Tue, 18 Jul 2023 20:25:31 +0800</pubDate>
      
      <guid>https://blog.laelaps.us/leetcodes/53/</guid>
      <description>前言 我一开始想到的是使用双指针，但是写着写着发现还是有点复杂的，最后放弃了这种方法，因为之前做个这个题目，所以也很容易想到贪心。
贪心 思想 当sum &amp;lt;= 0时，重新将sum赋值为0，因为一个负数加上一个负数，那么他更小，如果他加上一个大于他的数，我们为什么不选择比他的那个数，而需要加上他呢。
Java public static int maxSubArray(int[] nums) { int max = Integer.MIN_VALUE; int sum = 0; for (int i = 0; i &amp;lt; nums.length; i++) { sum += nums[i]; max = Math.max(max, sum); if (sum &amp;lt;= 0) sum = 0; } return max; } Go func maxSubArray(nums []int) int { max := math.MinInt sum := 0 for _, num := range(nums){ sum += num if sum &amp;gt; max { max = sum } if sum &amp;lt;= 0 { sum = 0 } } return max } </description>
    </item>
    
  </channel>
</rss>
